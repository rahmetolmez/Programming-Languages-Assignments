;;;; Parser For The G++ Language
;;;  Gets tokens from the lexer and evaluates the results.
;;;  Implemented by using recursive rescent parsing algorithm.
;;;  BNF rules were converted to other rules that they are compatible with this algorithm.

;;   Author: Rahmet Ali Olmez 
;;   January 2021

(load "gpp_lexer.lisp")


(defstruct ast-node
	type
	name
	val
	children)

(defstruct id
	name
	val)

(setf ast nil)
(setf ast (append ast (list (make-ast-node :type "END" :name "END" :val 0 :children (list nil)))))
(setf ids nil)
(setf last-id nil)
(setf symbols (list "KW_AND" "KW_OR" "KW_NOT" "KW_EQUAL" "KW_LESS" "KW_NIL" "KW_LIST" "KW_APPEND" "KW_CONCAT"
					 "KW_SET" "KW_DEFFUN" "KW_FOR" "KW_IF" "KW_EXIT" "KW_LOAD" "KW_DISP" "KW_TRUE" "KW_FALSE" 
					 "OP_PLUS" "OP_MINUS" "OP_DIV" "OP_MULT" "OP_DBLMULT" "IDENTIFIER" "OP_OP" "OP_CP" "OP_OC" "OP_CC" "OP_COMMA" "VALUE"))

(setf stream (list "OP_OP" "KW_SET" "IDENTIFIER" "OP_OP" "OP_MINUS" "VALUE" "OP_OP" "OP_MULT" "VALUE" "VALUE" "OP_CP" "OP_CP" "OP_CP"))
(setf value-stream (list "rahmet" 7 2 3))
(setf value-stream nil)
(setf stream nil)

(defun start-p(outStream)
	(let (result)
	(if (not (setf result (expi-p)))
		(if (not (setf result (explisti-p)))
			(progn
				(print-error)
				(return-from start-p nil)
			)
		)
	)
	(format outStream "~%SYNTAX IS OK. RESULT: ~d~%" result)
	(return-from start-p 1)
	)
)

(defun expi-p()
	(print "entering expi")
	(let (val)
	(setf val nil)
	(if (not (setf val (identifier-p)))
		(if (not (setf val (value-p)))
			(if (not (setf val (plus-p)))
				(if (not (setf val (minus-p)))
					(if (not (setf val (mult-p)))
						(if (not (setf val (dblmult-p)))
							(if (not (setf val (div-p)))
								(if (not (setf val (set-p)))
									(if (not (setf val (deffun-p)))
										(if (not (setf val (call-p)))
											(if (not (setf val (if-p)))
												(if (not (setf val (for-p)))
													(if (not (setf val (list-p)))
														(return-from expi-p nil))))))))))))))
	(print "exiting expi")
	(return-from expi-p val)))

(defun expb-p()
	(print "entering expb")
	(let (val)
	(setf val nil)
	(if (not (setf val (value-p)))					;has to be binary value!
		(if (not (setf val (and-p)))
			(if (not (setf val (or-p)))
				(if (not (setf val (not-p)))
					(if (not (setf val (equal-p)))
						(return-from expb-p nil))))))
		
	(print "exiting expb")
	(return-from expb-p val)))

(defun explisti-p()
	(print "entering explisti")
	(let (val)
	(setf val nil)
	(if (not (setf val (list-value-p)))					
		(if (not (setf val (nil-p)))
			(if (not (setf val (concat-p)))
				(if (not (setf val (append-p)))
					(return-from explisti-p nil)))))
		
	(print "exiting explisti")
	(return-from explisti-p val)))

(defun identifier-p()
	(if (not (equal (car stream) "IDENTIFIER"))
		(return-from identifier-p nil)
		(setf stream (cdr stream)))	
	(let (id result)
	(setf id (car value-stream))
	(if (cdr (assoc id ids :test #'equalp))
		(progn
		(setf result (cdr (assoc id ids :test #'equalp))))
		(setf result 0))
	(setf last-id id)
	(setf ast (append ast (list (make-ast-node :type "IDENTIFIER" :name id :val result :children (list nil)))))
	(setf value-stream (cdr value-stream))
	(format t "IDENTIFIER OK: ~s~%" result)
	(return-from identifier-p result)))

(defun value-p()
	(print "entering value")
	(if (not (equal (car stream) "VALUE"))
		(return-from value-p nil)
		(setf stream (cdr stream))
	)
	(let (result)
	(setf result (car value-stream))
	(setf ast (append ast (list (make-ast-node :type "VALUE" :name "VALUE" :val result :children (list nil)))))
	(setf value-stream (cdr value-stream))
	(format t "VALUE OK: ~d~%" result)
	(return-from value-p result)
	)
)

(defun plus-p()
	(print "entering plus")
	(let (lval rval result)
	(print stream)
	(if (not (equal (car stream) "OP_OP"))
		(return-from plus-p nil)
		;(setf stream (cdr stream))
	)
	(print stream)
	(if (not (equal (car (cdr stream)) "OP_PLUS"))
		(return-from plus-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(print stream)
	(if (not (setf lval (expi-p)))
		(progn 
			(print "ERROR: expi a")
			(format t "laval: ~d~%" lval)
			(return-from plus-p nil)
		)
	)
	(print stream)
	(if (not (setf rval (expi-p)))
		(return-from plus-p nil)
	)
	(print stream) (terpri)
	(if (not (equal (car stream) "OP_CP"))
		(return-from plus-p nil)
		(setf stream (cdr stream))
	)
	(print stream)
	;calculation
	(if (and (numberp lval) (numberp rval))
		(setf result (+ lval rval))
		(setf result nil)
	)
	
	(setf ast (append ast (list (make-ast-node :type "PLUS-P" :name "PLUS-P" :val result :children (list nil)))))
	(format t "PLUS OK: ~d ~%" result)
	(return-from plus-p result)
	)
)

(defun minus-p()
	(print "entering minus")
	(let (lval rval result)
	(print stream)
	;(print "debug1")
	(if (not (equal (car stream) "OP_OP"))
		(return-from minus-p nil)
		;(setf stream (cdr stream))
	)
	;(print "debug")
	(print stream)
	(if (not (equal (car (cdr stream)) "OP_MINUS"))
		(return-from minus-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(print stream)
	(if (not (setf lval (expi-p)))
		(progn 
			(print "ERROR: expi a")
			(format t "laval: ~d~%" lval)
			(return-from minus-p nil)
		)
	)
	(print stream)
	(if (not (setf rval (expi-p)))
		(return-from minus-p nil)
	)
	(print stream) (terpri)
	(if (not (equal (car stream) "OP_CP"))
		(return-from minus-p nil)
		(setf stream (cdr stream))
	)
	;calculation
	(if (and (numberp lval) (numberp rval))
		(setf result (- lval rval))
		(setf result nil)
	)
	
	(setf ast (append ast (list (make-ast-node :type "MINUS-P" :name "MINUS-P" :val result :children (list nil)))))
	(format t "MINUS OK: ~d ~%" result)
	(return-from minus-p result)
	)	
)

(defun mult-p()
	(print "entering mult")
	(let (lval rval result)
	(print stream)
	;(print "debug1")
	(if (not (equal (car stream) "OP_OP"))
		(return-from mult-p nil)
		;(setf stream (cdr stream))
	)
	;(print "debug")
	(print stream)
	(if (not (equal (car (cdr stream)) "OP_MULT"))
		(return-from mult-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(print stream)
	(if (not (setf lval (expi-p)))
		(progn 
			(print "ERROR: expi a")
			(format t "lval: ~d~%" lval)
			(return-from mult-p nil)
		)
	)
	(print stream)
	(if (not (setf rval (expi-p)))
		(return-from mult-p nil)
	)
	(print stream) (terpri)
	(if (not (equal (car stream) "OP_CP"))
		(return-from mult-p nil)
		(setf stream (cdr stream))
	)
	;calculation
	(if (and (numberp lval) (numberp rval))
		(setf result (* lval rval))
		(setf result nil)
	)
	
	(setf ast (append ast (list (make-ast-node :type "MULT-P" :name "MULT-P" :val result :children (list nil)))))
	(format t "MULT OK: ~d ~%" result)
	(return-from mult-p result)
	)	
)

(defun dblmult-p()
	(print "entering dblmult")
	(let (lval rval result)
	(print stream)
	;(print "debug1")
	(if (not (equal (car stream) "OP_OP"))
		(return-from dblmult-p nil)
		;(setf stream (cdr stream))
	)
	;(print "debug")
	(print stream)
	(if (not (equal (car (cdr stream)) "OP_DBLMULT"))
		(return-from dblmult-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(print stream)
	(if (not (setf lval (expi-p)))
		(progn 
			(print "ERROR: expi a")
			(format t "lval: ~d~%" lval)
			(return-from dblmult-p nil)
		)
	)
	(print stream)
	(if (not (setf rval (expi-p)))
		(return-from dblmult-p nil)
	)
	(print stream) (terpri)
	(if (not (equal (car stream) "OP_CP"))
		(return-from dblmult-p nil)
		(setf stream (cdr stream))
	)
	;calculation
	(if (and (numberp lval) (numberp rval))
		(setf result (expt lval rval))
		(setf result nil)
	)
	
	(setf ast (append ast (list (make-ast-node :type "DBLMULT-P" :name "DBLMULT-P" :val result :children (list nil)))))
	(format t "DBLMULT OK: ~d ~%" result)
	(return-from dblmult-p result)
	)	
)

(defun div-p()
	(print "entering div")
	(let (lval rval result)
	(print stream)
	;(print "debug1")
	(if (not (equal (car stream) "OP_OP"))
		(return-from div-p nil)
		;(setf stream (cdr stream))
	)
	;(print "debug")
	(print stream)
	(if (not (equal (car (cdr stream)) "OP_DIV"))
		(return-from div-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(print stream)
	(if (not (setf lval (expi-p)))
		(progn 
			(print "ERROR: expi a")
			(format t "lval: ~d~%" lval)
			(return-from div-p nil)
		)
	)
	(print stream)
	(if (not (setf rval (expi-p)))
		(return-from div-p nil)
	)
	(print stream) (terpri)
	(if (not (equal (car stream) "OP_CP"))
		(return-from div-p nil)
		(setf stream (cdr stream))
	)
	;calculation
	(if (and (numberp lval) (numberp rval))
		(setf result (/ lval rval))
		(setf result nil)
	)
	
	(setf ast (append ast (list (make-ast-node :type "DIV-P" :name "DIV-P" :val result :children (list nil)))))
	(format t "DIV OK: ~d ~%" result)
	(return-from div-p result)
	)	
)

(defun set-p()
	(let (id result)
	(print stream)
	(if (not (equal (car stream) "OP_OP"))
		(return-from set-p nil)
	)	
	(if (not (equal (car (cdr stream)) "KW_SET"))
		(return-from set-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf id (identifier-p)))
		(progn 
			(print "ERROR: id")
			(return-from set-p nil)
		)
	)
	(if (not (setf result (expi-p)))
		(return-from set-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from set-p nil)
		(setf stream (cdr stream))
	)
	;if identifier already exists, change the value
	(print "q1")
	(if (cdr (assoc last-id ids :test #'equalp))
		(setf (cdr (assoc last-id ids :test #'equalp)) result)
		(setf ids (append ids (list (cons last-id result))))
	)
	
	(print ids)
	(setf ast (append ast (list (make-ast-node :type "SET-P" :name "SET-P" :val result :children (list nil)))))
	(format t "SET OK: ~s = ~d~%" last-id result)
	(return-from set-p result)
	)
)

(defun deffun-p()
	)

(defun call-p()
	)

(defun if-p()
	(let (condition result)
	(if (not (equal (car stream) "OP_OP"))
		(return-from if-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_IF"))
		(return-from if-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf condition (expb-p)))
		(return-from if-p nil)
	)
	;!!!!return false if condition not t (not nil)
	(if (= condition 0)
		(progn
			(setf ast (append ast (list (make-ast-node :type "IF-P" :name "IF-P" :val condition :children (list nil)))))
			(format t "IF OK: ~d (BLOCK NOT EVALUATED)~%" condition)
			(return-from if-p condition)
		)
	)
	(if (not (setf result (expi-p)))
		(return-from if-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from if-p nil)
		(setf stream (cdr stream))
	)

	(setf ast (append ast (list (make-ast-node :type "IF-P" :name "IF-P" :val result :children (list nil)))))
	(format t "IF OK: ~d (BLOCK EVALUATED)~%" result)
	(return-from if-p result)
	)
)

(defun for-p()
	(print "entering for")
	(print stream)
	(let (begin-val end-val result id-val last-id-temp stream-temp value-stream-temp)
	(if (not (equal (car stream) "OP_OP"))
		(return-from for-p nil)
	)
	(print "for 1")
	(if (not (equal (car (cdr stream)) "KW_FOR"))
		(return-from for-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (equal (car stream) "OP_OP"))
		(return-from for-p nil)
		(setf stream (cdr stream))
	)
	(if (not (setf id-val (identifier-p)))
		(return-from for-p nil)
	)
	;;;;;;;;;
	;if id already in the ids list, just change the value (initialize as 0)
	(setf last-id-temp last-id)
	(if (cdr (assoc last-id ids :test #'equalp))
		(setf (cdr (assoc last-id ids :test #'equalp)) 0)
		(setf ids (append ids (list (cons last-id 0))))
	)
	;;;;;;;;;
	(if (not (setf begin-val (expi-p)))
		(return-from for-p nil)
	)
	;set identifier to begin-val
	(setf (cdr (assoc last-id-temp ids :test #'equalp)) begin-val)

	(if (not (setf end-val (expi-p)))
		(return-from for-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from for-p nil)
		(setf stream (cdr stream))
	)
	;doing this expi in a for loop
	(setf stream-temp stream)
	(setf value-stream-temp value-stream)
	(dotimes (i (- end-val (cdr (assoc last-id-temp ids :test #'equalp))))
		(print stream)
		(print "setting stream  and value stream to temp")
		(setf stream stream-temp)
		(setf value-stream value-stream-temp)
		(print stream)
		(if (not (setf result (expi-p)))	;!
			(return-from for-p nil)
		)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from for-p nil)
		(setf stream (cdr stream))
	)

	(setf ast (append ast (list (make-ast-node :type "FOR-P" :name "FOR-P" :val result :children (list nil)))))
	(format t "FOR OK: ~d~%" result)
	(return-from for-p result)
	)
)

(defun list-p()
	(let (result end-loop)
	(if (not (equal (car stream) "OP_OP"))
		(return-from list-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_LIST"))
		(return-from list-p nil)
		(setf stream (cdr (cdr stream)))
	)
	
	(setf end-loop nil)
	(loop while (not end-loop)
		do
			(if (equal (car stream) "VALUE")
				(progn
					(setf result (append result (list (car value-stream))))
					(setf value-stream (cdr value-stream))
					(setf stream (cdr stream))
				)
				(setf end-loop t)
			)
	)

	(if (not (equal (car stream) "OP_CP"))
		(return-from list-p nil)
		(setf stream (cdr stream))
	)
	(setf ast (append ast (list (make-ast-node :type "LIST-P" :name "LIST-P" :val result :children (list nil)))))
	(format t "LIST OK: ~d ~%" result)
	(return-from list-p result)
	)
)

(defun and-p()
	(let (lval rval result)
	(if (not (equal (car stream) "OP_OP"))
		(return-from and-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_AND"))
		(return-from and-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf lval (expb-p)))
		(return-from and-p nil)
	)
	(if (not (setf rval (expb-p)))
		(return-from and-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from and-p nil)
		(setf stream (cdr stream))
	)
	(if (and (not (= lval 0)) (not (= rval 0)))
		(setf result 1)
		(setf result 0)
	)
	(setf ast (append ast (list (make-ast-node :type "AND-P" :name "AND-P" :val result :children (list nil)))))
	(format t "AND OK: ~d ~%" result)
	(return-from and-p result)
	)	
)

(defun or-p()
	(let (lval rval result)
	(if (not (equal (car stream) "OP_OP"))
		(return-from or-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_OR"))
		(return-from or-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf lval (expb-p)))
		(return-from or-p nil)
	)
	(if (not (setf rval (expb-p)))
		(return-from or-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from or-p nil)
		(setf stream (cdr stream))
	)
	(if (and (= lval 0) (= rval 0))
		(setf result 0)
		(setf result 1)
	)
	(setf ast (append ast (list (make-ast-node :type "OR-P" :name "OR-P" :val result :children (list nil)))))
	(format t "OR OK: ~d ~%" result)
	(return-from or-p result)
	)	
)

(defun not-p()
	(let (lval result)
	(if (not (equal (car stream) "OP_OP"))
		(return-from not-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_NOT"))
		(return-from not-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf lval (expb-p)))
		(return-from not-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from not-p nil)
		(setf stream (cdr stream))
	)
	(if (= lval 0)
		(setf result 1)
		(setf result 0)
	)
	(setf ast (append ast (list (make-ast-node :type "NOT-P" :name "NOT-P" :val result :children (list nil)))))
	(format t "NOT (FUNCTION) OK: ~d ~%" result)
	(return-from not-p result)
	)
)

(defun equal-p()
	(let (lval rval result)
	(if (not (equal (car stream) "OP_OP"))
		(return-from equal-p nil)
	)
	(if (not (equal (car (cdr stream)) "KW_EQUAL"))
		(return-from equal-p nil)
		(setf stream (cdr (cdr stream)))
	)
	(if (not (setf lval (expi-p)))
		(return-from equal-p nil)
	)
	(if (not (setf rval (expi-p)))
		(return-from equal-p nil)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from equal-p nil)
		(setf stream (cdr stream))
	)
	(if (= lval rval)
		(setf result 1)
		(setf result 0)
	)
	(setf ast (append ast (list (make-ast-node :type "EQUAL-P" :name "EQUAL-P" :val result :children (list nil)))))
	(format t "EQUAL OK: ~d ~%" result)
	(return-from equal-p result)
	)
)

(defun list-value-p()
	(let (result end-loop)
	(if (not (equal (car stream) "OP_OP"))
		(return-from list-value-p nil)
	)
	(if (equal (car (cdr stream)) "OP_CP")
		(setf stream (cdr (cdr stream)))
		(return-from list-value-p (list nil))
	)
	(setf stream (cdr stream))
	;while tokens are VALUE, get all the values
	(setf end-loop nil)
	(loop while (not end-loop)
		do
			(if (equal (car stream) "VALUE")
				(progn
					(setf result (append result (list (car value-stream))))
					(setf value-stream (cdr value-stream))
					(setf stream (cdr stream))
				)
				(setf end-loop t)
			)
	)
	(if (not (equal (car stream) "OP_CP"))
		(return-from list-value-p nil)
		(setf stream (cdr stream))
	)
	(setf ast (append ast (list (make-ast-node :type "LIST-VALUE-P" :name "LIST-VALUE-P" :val result :children (list nil)))))
	(format t "LIST-VALUE OK: ~d ~%" result)
	(return-from list-value-p result)
	)
)

(defun nil-p()
	)

(defun concat-p()
	)

(defun append-p()
	)

(defun print-error()
	(format t "~%SYNTAX ERROR: EXPRESSION NOT RECOGNIZED~%"))

(defun file-to-value-stream (fileName)
	(let (newList)
		(with-open-file (inStream fileName)
			(loop for element = (read inStream nil) until (null element) 
				do
            		(progn
            			(if (numberp (car (list element)))
            				(setf value-stream (append value-stream (list (car (list element)))))
            				(progn
            					(if (not (find (string (car (list element))) symbols :test #'equal))
            						(setf value-stream (append value-stream (list (string (car (list element))))))))))))
	(return-from file-to-value-stream newList)))

(defun file-to-stream (fileName)
	(let (newList)
		(with-open-file (inStream fileName)
			(loop for element = (read inStream nil) until (null element) 
				do
            		(progn
            			(if (not (numberp (car (list element))))
            				
            				(progn
            					(if (find (string (car (list element))) symbols :test #'equal)
            						(setf stream (append stream (list (string (car (list element))))))))))))
	(return-from file-to-stream newList)))

(defun main()
	(let (end-loop)
	(with-open-file (outStream "output_lisp.txt" :direction :output)
	(loop while (not end-loop)
		do
			(progn
				(gppinterpreter)
				(file-to-stream "parsed_lisp.txt")
				(file-to-value-stream "parsed_lisp.txt")
				(print value-stream)
				(print stream)
				(setf end-loop (not (start-p outStream)))
				(print ids)
				(terpri)
			)
	)
	)
))

(main)




;(start-p)
;
;
;(setf stream (list "OP_OP" "KW_SET" "IDENTIFIER" "OP_OP" "OP_MINUS" "IDENTIFIER" "OP_OP" "OP_MULT" "VALUE" "VALUE" "OP_CP" "OP_CP" "OP_CP"))
;(setf value-stream (list "rahmet" "rahmet" 3 7))
;(start-p)
;
;(setf stream (list "OP_OP" "OP_MINUS" "IDENTIFIER" "VALUE" "OP_CP"))
;(setf value-stream (list "rahmet" -9))
;(start-p)
;
;(setf stream (list "OP_OP" "KW_SET" "IDENTIFIER" "VALUE" "OP_CP"))
;(setf value-stream (list "mehmet" 23))
;(start-p)
;
;(setf stream (list "OP_OP" "KW_SET" "IDENTIFIER" "VALUE" "OP_CP"))
;(setf value-stream (list "veli" 81))
;(start-p)
;
;(setf stream (list "OP_OP" "OP_MINUS" "IDENTIFIER" "IDENTIFIER" "OP_CP"))
;(setf value-stream (list "veli" "mehmet"))
;(start-p)
;
;(setf stream (list "OP_OP" "KW_IF" "OP_OP" "KW_AND" "VALUE" "VALUE" "OP_CP" "OP_OP" "OP_PLUS" "VALUE" "VALUE" "OP_CP" "OP_CP"))
;(setf value-stream (list 1 1 7 3))
;(start-p)
;
;(setf stream (list "OP_OP" "KW_FOR" "OP_OP" "IDENTIFIER" "VALUE" "VALUE" "OP_CP" "OP_OP" "KW_SET" "IDENTIFIER" "OP_OP" "OP_PLUS" "IDENTIFIER" "VALUE" "OP_CP" "OP_CP" "OP_CP"))
;(setf value-stream (list "counter" 0 10 "mehmet" "mehmet" 1))
;(start-p)
;
;(setf stream (list "OP_OP" "KW_LIST" "VALUE" "VALUE" "VALUE" "VALUE" "OP_CP"))
;(setf value-stream (list 1 13 44 76))
;(start-p)

;(print ast)